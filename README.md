# ✨Particle Repo
Это репозиторий партиклов, которые можно использовать для сборки своих партиклов.

> ⚠️ Некоторые партиклы могут использовать внешние сервера для хранения своих слоев, я не несу ответственности за их доступность.

## Доступные движки
- `core/busybox` — минималистичная оболочка bash и базовые утилиты, доступные под любую платформу. Используйте, чтобы запукать .sh скрипты на Windows. Подробнее в [core/busybox](repo/core/busybox/README.md)
- `core/python`— Python 3, доступный под Windows и UNIX (libc). Подробнее в [core/python](repo/core/python/README.md)

## Что такое партиклы?
[Readme для тех, кто в теме](README_LOL.md)

Партиклы (Particles, частицы) — это готовые решения, сборку которых можно воспроизвести практически на любой платформе. В отличие от Docker, система партиклов нацелена на создание унифицированных сборок, а не их запуск. Поэтому она не предоставляет виртуализацию, изоляцию, операционные системы в контейнерах и систему разрешений.

### Зачем
Я знаю, что для компиляции/сборки ПО есть популярные системы непрерывных интеграций, тот же GitHub Actions, а если у вас есть возможность использовать вышеупомянутый Docker, то используйте его. Однако данная система разрабатывалась для игрового хостинга [FruitSpace](https://fruitspace.ru), где игроки любят ставить моды, текстурпаки и всячески издеваться над играми. Для разработчиков модов головная боль поддерживать игроков с Windows 7-10, умников на самых различных дистрибутивах Linux и macOS, и тех, кто почему-то играет с телефона. Пользователи тыкают на всё подряд и пытаются совместить несовместимое, в результате чего иногда сами игры перестают запускаться, а лечится данная беда только переустановкой. В то же время владельцы приватных серверов хотят наличие некторых модов и текстур у игроков по умолчанию. И вот с этим адом надо было бороться.

Были приняты следующие критерии: нужна система для создания сборок игр прямо на компьютерах пользователей, с возможностью применять патчи по частям и предсказуемым результатом, как по `рецепту` (playbook).

### Как оно работает
Партиклы это буквально частицы, которые собираются на основе еще меньших частиц, например: Beat Saber + патч для поддержки модов + сами моды + фикс для SteamVR + пользовательские треки = ваша сборка, ваш партикл, которым стоит гордиться.


`Партиклы` это пара `манифест` и `слой`, связанный с ним.

`Слой` содержит измененные файлы относительно предыдущих слоев

`Манифест` содержит описание партикла и `рецепт`

Вот пример манифеста:

```json
{
  "name": "particle_name",
  "author": "Particle Author",
  "note": "Short note for some info",
  "block": "md5, autogenerated",
  "meta": {
    "sl_mods": "BeatSaver,Chroma,MorePlaylists,NoodleExtensions"
  },
  "recipe": {
      "base": "fruitspace/beat_saber",
      "apply": [
        "cooldude/beatsaber_ipa@4.2",
        "cooldude/saberloader"
      ],
      "engines": [
        "core/python@3.9",
        "core/busybox"
      ],
      "run": [
        "python $src/main.py",
        "mv $src/songs/* \"$dist/Beat Saber_Data/CustomLevels\""
      ]
    }
}
```

Здесь `block` это слой для данного партикла, `meta` это буквально переменные окружения которые нужны для запуска каких-либо действий

**Рецепт `recipe`**

* Любой партикл имеет основу (`base`) — файлы, на основе которых уже и выполняются действия, в примере это ванильные файлы игры. Если вы хотите создать партикл с нуля (без базы), то укажите `blank`. Партикл базы должен быть пассивным\*
* `apply` секция содержит активные партиклы, которые будут выполнять действия по отношению к базе. В примере это установить загрузчик модификаций и использовать скрипт для скачки модов, указанных в окружении как `sl_mods`
* `engines` содержит движки, необходимые для запуска скриптов. Они предоставляют команды/бинарники, которые можно использлвать из `run` и своих скриптов. Движки это пассивные партиклы, поэтому вы можете создавать свои сборки, например python с keras, numpy и matplotlib (не jupyter, но тоже пойдет)
* `run` секция содержит команды, которые необходимо выполнить на следующем слое (либо на этом же, но после выполнения стоит убрать секцию чтобы не делать партикл активным)

\*пассивные партиклы - это те, у которых нет секции `run`, а значит они уже готовы для использования другими партиклами в качестве основы (базы) без необходимости применять патчи/действия из `apply` секции (То есть не надо заново качать python, gcc и еще 5гб тулчейнов, чтобы собрать слой).

## Как сделать свой партикл:
1) `particle init`
      создаст пустой манифест с базой blank и основные папки dist, engines, src и out
2) `particle prepare`
      готовит партикл из базы и apply (активных партиклов), а также составляет список md5 хэшей результата базы в integrity.json
3) здесь делаете свою мешанину в dist и допиливаете команды в run
4) `particle build`
      собирает партикл в out из dist, добавляя новые файлы как есть, изменения в патчфайлы filename.ext.patch
      (например config.xml изменился, пакуем config.xml.patch), удаления в .deletions. Все это пакуется в слой
      и считается md5, который ставится в поле block манифеста